{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/viet/Desktop/stage/yobeen agrotech app/node_modules/react-native-dashed-progress/dashed-progress/index.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { PureComponent } from \"react\";\nimport { Svg, Text, Path, Line } from \"react-native-svg\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport PropTypes from \"prop-types\";\n\nvar _Dimensions$get = Dimensions.get(\"window\"),\n    height = _Dimensions$get.height,\n    width = _Dimensions$get.width;\n\nvar responsiveHeight = function responsiveHeight(h) {\n  return height * (h / 100);\n};\n\nexport var DashedProgress = function (_PureComponent) {\n  _inherits(DashedProgress, _PureComponent);\n\n  var _super = _createSuper(DashedProgress);\n\n  function DashedProgress(props) {\n    var _this;\n\n    _classCallCheck(this, DashedProgress);\n\n    _this = _super.call(this, props);\n    var radius = props.radius,\n        barWidth = props.barWidth,\n        strokeThickness = props.strokeThickness,\n        indicatorWidth = props.indicatorWidth;\n    var center = radius + Math.max(barWidth, indicatorWidth) + strokeThickness;\n    _this.state = {\n      last_stroke_index: 0,\n      last_trail_index: 0,\n      bigCircle: [],\n      number: [],\n      stopIndicator: {\n        fromX: center,\n        fromY: center - (radius - barWidth),\n        toX: center,\n        toY: center - (radius + indicatorWidth)\n      }\n    };\n\n    _this.increment_timer = function () {};\n\n    _this.decrement_timer = function () {};\n\n    return _this;\n  }\n\n  _createClass(DashedProgress, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      try {\n        if (this.props.fill != prevProps.fill) {\n          if (this.props.fill > prevProps.fill) {\n            this.increaseWeight();\n          } else {\n            this.decreaseWeight();\n          }\n        }\n      } catch (error) {\n        console.log(\"catch error at in getDerivedStateFromProps  >>>>> \", error);\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      try {\n        this.getPathDirections().then(function (response) {\n          if (response) {\n            _this2.increaseWeight();\n          }\n        });\n      } catch (error) {\n        console.log(\"catch error at componentDidMount  >>>>> \", error);\n      }\n    }\n  }, {\n    key: \"getPathDirections\",\n    value: function getPathDirections() {\n      var _this3 = this;\n\n      var _this$props = this.props,\n          radius = _this$props.radius,\n          barWidth = _this$props.barWidth,\n          strokeThickness = _this$props.strokeThickness,\n          dividerNumber = _this$props.dividerNumber,\n          indicatorWidth = _this$props.indicatorWidth,\n          countBars = _this$props.countBars,\n          divideEnabled = _this$props.divideEnabled,\n          trailColor = _this$props.trailColor;\n      return new Promise(function (resolve, reject) {\n        try {\n          var count = 0;\n          var dashed = [];\n          var j;\n          var textX;\n          var textY;\n          number = [];\n          var i;\n          var addDividedNumber = false;\n          var text = 0;\n          var ten_counter = 0;\n          var center = radius + Math.max(barWidth, indicatorWidth) + strokeThickness;\n          var decrement_i = 360 / ((countBars + 0.001) * 2);\n\n          for (i = 180; i >= 0; i -= decrement_i) {\n            if (i < 90) {\n              j = i - 90;\n            } else {\n              j = i + 90;\n            }\n\n            var angle = j * Math.PI / 90;\n            var fromX = center + Math.sin(angle) * radius;\n            var fromY = center + Math.cos(angle) * radius;\n            var toX = center + Math.sin(angle) * (radius + barWidth);\n            var toY = center + Math.cos(angle) * (radius + barWidth);\n\n            if (divideEnabled) {\n              if (ten_counter == (dividerNumber || 10)) {\n                text = text + 1;\n                addDividedNumber = true;\n                var extrawidth = barWidth + responsiveHeight(0.2);\n                textX = center + Math.sin(angle) * (radius - barWidth - extrawidth);\n                textY = center + Math.cos(angle) * (radius - barWidth - extrawidth);\n                fromX = center + Math.sin(angle) * (radius + barWidth);\n                fromY = center + Math.cos(angle) * (radius + barWidth);\n                toX = center + Math.sin(angle) * (radius - barWidth);\n                toY = center + Math.cos(angle) * (radius - barWidth);\n                ten_counter = 0;\n              }\n\n              if (ten_counter < dividerNumber || 10) {\n                ten_counter = ten_counter + 1;\n              }\n\n              if (addDividedNumber) {\n                number.push({\n                  textX: textX,\n                  textY: textY,\n                  text: text,\n                  stroke: trailColor\n                });\n                addDividedNumber = false;\n              }\n            }\n\n            var fromX_stopIndicator = center + Math.sin(angle) * (radius + indicatorWidth);\n            var fromY_stopIndicator = center + Math.cos(angle) * (radius + indicatorWidth);\n            var toX_stopIndicator = center + Math.sin(angle) * (radius - barWidth);\n            var toY_stopIndicator = center + Math.cos(angle) * (radius - barWidth);\n            var stop_indicator = {\n              fromX: fromX_stopIndicator,\n              fromY: fromY_stopIndicator,\n              toX: toX_stopIndicator,\n              toY: toY_stopIndicator\n            };\n            dashed.push({\n              fromX: fromX,\n              fromY: fromY,\n              toX: toX,\n              toY: toY,\n              stroke: trailColor,\n              stopIndicator: stop_indicator\n            });\n            count = count + 1;\n          }\n\n          _this3.setState({\n            reaload: true,\n            bigCircle: dashed,\n            number: number\n          }, function () {\n            if (_this3.state.bigCircle.length <= 0) {\n              resolve(false);\n            }\n          });\n\n          resolve(true);\n        } catch (error) {\n          console.log(\"catch error at getPathDirections >>>>> \", error);\n        }\n      });\n    }\n  }, {\n    key: \"increaseWeight\",\n    value: function increaseWeight() {\n      var _this4 = this;\n\n      try {\n        var _this$props2 = this.props,\n            strokeColor = _this$props2.strokeColor,\n            fill = _this$props2.fill,\n            duration = _this$props2.duration;\n        var interval_time = 3;\n\n        if (fill > 0) {\n          interval_time = duration / (fill - this.state.last_stroke_index);\n        }\n\n        var i = this.state.last_trail_index;\n        var k = i;\n        var diff = 1;\n\n        if (interval_time < 100) {\n          diff = parseInt(100 / interval_time);\n        }\n\n        clearInterval(this.increment_timer);\n        clearInterval(this.decrement_timer);\n        this.increment_timer = setInterval(function () {\n          try {\n            if (i <= fill) {\n              var bigCircle = _this4.state.bigCircle;\n              var stopIndicator = _this4.state.stopIndicator;\n\n              for (k = i; k <= i + diff; k++) {\n                if (bigCircle.length > k) {\n                  if (bigCircle[k].stroke != strokeColor && k <= fill) {\n                    stopIndicator = bigCircle[k].stopIndicator;\n                    bigCircle[k].stroke = strokeColor;\n                  } else {\n                    break;\n                  }\n                } else {\n                  break;\n                }\n              }\n\n              _this4.setState({\n                last_stroke_index: k - 1,\n                last_trail_index: k,\n                bigCircle: bigCircle,\n                stopIndicator: stopIndicator\n              });\n\n              i = k;\n            } else {\n              clearInterval(_this4.increment_timer);\n            }\n          } catch (err) {\n            console.log(err);\n          }\n        }, interval_time);\n      } catch (error) {\n        console.log(\"catch error at increaseWeight >>>>> \", error);\n      }\n    }\n  }, {\n    key: \"decreaseWeight\",\n    value: function decreaseWeight() {\n      var _this5 = this;\n\n      try {\n        var _this$props3 = this.props,\n            trailColor = _this$props3.trailColor,\n            countBars = _this$props3.countBars,\n            fill = _this$props3.fill,\n            duration = _this$props3.duration;\n        var interval_time = 3;\n\n        if (fill >= 0) {\n          interval_time = duration / (this.state.last_trail_index - fill);\n        }\n\n        var last_length = fill;\n        var i = this.state.last_stroke_index;\n\n        if (i >= countBars + 1) {\n          i = countBars;\n        }\n\n        var k = i;\n        var diff = 1;\n\n        if (interval_time < 100) {\n          diff = Math.round(100 / interval_time);\n        }\n\n        clearInterval(this.decrement_timer);\n        clearInterval(this.increment_timer);\n        this.decrement_timer = setInterval(function () {\n          try {\n            if (i >= last_length && i > 0) {\n              var bigCircle = _this5.state.bigCircle;\n              var stopIndicator = _this5.state.stopIndicator;\n\n              for (k = i; k > i - diff; k--) {\n                if (bigCircle[k].stroke != trailColor && k >= last_length && k > 0) {\n                  stopIndicator = bigCircle[k].stopIndicator;\n                  bigCircle[k].stroke = trailColor;\n                } else {\n                  break;\n                }\n              }\n\n              _this5.setState({\n                last_trail_index: k + 1,\n                last_stroke_index: k,\n                bigCircle: bigCircle,\n                stopIndicator: stopIndicator\n              });\n\n              i = k;\n            } else {\n              clearInterval(_this5.decrement_timer);\n            }\n          } catch (err) {\n            console.log(err);\n          }\n        }, interval_time);\n      } catch (error) {\n        console.log(\"catch error at decreaseWeight >>>>> \", error);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      var _this$props4 = this.props,\n          containerStyle = _this$props4.containerStyle,\n          fill = _this$props4.fill,\n          radius = _this$props4.radius,\n          barWidth = _this$props4.barWidth,\n          strokeThickness = _this$props4.strokeThickness,\n          strokeLinecap = _this$props4.strokeLinecap,\n          showTooltip = _this$props4.showTooltip,\n          tooltipSize = _this$props4.tooltipSize,\n          tooltipColor = _this$props4.tooltipColor,\n          tooltipFamily = _this$props4.tooltipFamily,\n          divideEnabled = _this$props4.divideEnabled,\n          text = _this$props4.text,\n          dividerNumberSize = _this$props4.dividerNumberSize,\n          showIndicator = _this$props4.showIndicator,\n          strokeColor = _this$props4.strokeColor,\n          indicatorWidth = _this$props4.indicatorWidth,\n          indicatorColor = _this$props4.indicatorColor;\n      var center = radius + Math.max(barWidth, indicatorWidth) + strokeThickness;\n      var size = center * 2;\n      var textFontSize = tooltipSize || 12;\n\n      if (tooltipSize != undefined) {\n        if (tooltipSize >= center) {\n          textFontSize = center;\n        } else {\n          textFontSize = tooltipSize;\n        }\n      }\n\n      return React.createElement(View, {\n        style: containerStyle,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 368,\n          columnNumber: 7\n        }\n      }, React.createElement(Svg, {\n        width: \"\" + size,\n        height: \"\" + size,\n        style: {\n          backgroundColor: \"transparent\"\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 369,\n          columnNumber: 9\n        }\n      }, this.state.bigCircle.map(function (item, index) {\n        return React.createElement(Line, {\n          key: \"line_\" + index,\n          x1: item.fromX,\n          y1: item.fromY,\n          x2: item.toX,\n          y2: item.toY,\n          stroke: item.stroke,\n          strokeWidth: strokeThickness,\n          strokeLinecap: strokeLinecap,\n          __self: _this6,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 376,\n            columnNumber: 13\n          }\n        });\n      }), divideEnabled && this.state.number.map(function (item, index) {\n        return React.createElement(Text, {\n          key: \"number_\" + index,\n          x: item.textX,\n          y: item.textY + (dividerNumberSize || 9) / 3,\n          fill: item.stroke,\n          fontSize: dividerNumberSize || 9,\n          textAnchor: \"middle\",\n          __self: _this6,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 391,\n            columnNumber: 15\n          }\n        }, item.text);\n      }), showIndicator && React.createElement(Line, {\n        x1: this.state.stopIndicator.fromX,\n        y1: this.state.stopIndicator.fromY,\n        x2: this.state.stopIndicator.toX,\n        y2: this.state.stopIndicator.toY,\n        stroke: indicatorColor,\n        strokeWidth: strokeThickness,\n        strokeLinecap: strokeLinecap,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 405,\n          columnNumber: 13\n        }\n      }), showTooltip && React.createElement(Text, {\n        x: center,\n        y: center + textFontSize / 3,\n        textAnchor: \"middle\",\n        fontSize: textFontSize,\n        fontFamily: tooltipFamily,\n        fill: tooltipColor,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 418,\n          columnNumber: 13\n        }\n      }, text || fill + \"%\")));\n    }\n  }]);\n\n  return DashedProgress;\n}(PureComponent);\n\nfunction isPositiveNumber(response) {\n  if (response.fill < 0) {\n    console.error(new Error(\"fill must be greater than or equal to 0\"));\n  } else if (response.fill > response.countBars) {\n    console.error(new Error(\"fill must be less than or equal to \" + response.countBars));\n  }\n}\n\nDashedProgress.propTypes = {\n  radius: PropTypes.number,\n  barWidth: PropTypes.number,\n  indicatorWidth: PropTypes.number,\n  countBars: PropTypes.number,\n  strokeThickness: PropTypes.number,\n  fill: isPositiveNumber,\n  strokeLinecap: PropTypes.string,\n  trailColor: PropTypes.string,\n  strokeColor: PropTypes.string,\n  tooltipColor: PropTypes.string,\n  text: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  tooltipSize: PropTypes.number,\n  showTooltip: PropTypes.bool,\n  dividerNumber: PropTypes.number,\n  dividerNumberSize: PropTypes.number,\n  showIndicator: PropTypes.bool,\n  indicatorColor: PropTypes.string,\n  divideEnabled: PropTypes.bool,\n  duration: PropTypes.number,\n  containerStyle: PropTypes.object,\n  tooltipFamily: PropTypes.string\n};\nDashedProgress.defaultProps = {\n  radius: 100,\n  countBars: 100,\n  barWidth: 10,\n  indicatorWidth: 20,\n  strokeThickness: 1,\n  fill: 50,\n  trailColor: \"#000000\",\n  strokeColor: \"#008000\",\n  indicatorColor: \"#008000\",\n  tooltipColor: \"#008000\",\n  duration: 1000,\n  strokeLinecap: \"round\",\n  showIndicator: true,\n  showTooltip: true,\n  divideEnabled: false\n};","map":{"version":3,"sources":["/Users/viet/Desktop/stage/yobeen agrotech app/node_modules/react-native-dashed-progress/dashed-progress/index.js"],"names":["React","PureComponent","Svg","Text","Path","Line","PropTypes","Dimensions","get","height","width","responsiveHeight","h","DashedProgress","props","radius","barWidth","strokeThickness","indicatorWidth","center","Math","max","state","last_stroke_index","last_trail_index","bigCircle","number","stopIndicator","fromX","fromY","toX","toY","increment_timer","decrement_timer","prevProps","fill","increaseWeight","decreaseWeight","error","console","log","getPathDirections","then","response","dividerNumber","countBars","divideEnabled","trailColor","Promise","resolve","reject","count","dashed","j","textX","textY","i","addDividedNumber","text","ten_counter","decrement_i","angle","PI","sin","cos","extrawidth","push","stroke","fromX_stopIndicator","fromY_stopIndicator","toX_stopIndicator","toY_stopIndicator","stop_indicator","setState","reaload","length","strokeColor","duration","interval_time","k","diff","parseInt","clearInterval","setInterval","err","last_length","round","containerStyle","strokeLinecap","showTooltip","tooltipSize","tooltipColor","tooltipFamily","dividerNumberSize","showIndicator","indicatorColor","size","textFontSize","undefined","backgroundColor","map","item","index","isPositiveNumber","Error","propTypes","string","oneOfType","bool","object","defaultProps"],"mappings":"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","sourcesContent":["// COMOPONENT OR LIBRARY IMPORT\nimport React, { PureComponent } from \"react\";\nimport { Svg, Text, Path, Line } from \"react-native-svg\";\nimport { View, Dimensions } from \"react-native\";\nimport PropTypes from \"prop-types\";\n\nconst { height, width } = Dimensions.get(\"window\");\n\nconst responsiveHeight = h => {\n  return height * (h / 100);\n};\n\nexport class DashedProgress extends PureComponent {\n  constructor(props) {\n    super(props);\n    //calculate first position of stopIndicator\n    const { radius, barWidth, strokeThickness, indicatorWidth } = props;\n    const center =\n      radius + Math.max(barWidth, indicatorWidth) + strokeThickness;\n    //set animated state value\n    this.state = {\n      last_stroke_index: 0,\n      last_trail_index: 0,\n      bigCircle: [],\n      number: [],\n      stopIndicator: {\n        fromX: center,\n        fromY: center - (radius - barWidth),\n        toX: center,\n        toY: center - (radius + indicatorWidth)\n      }\n    };\n\n    this.increment_timer = () => {};\n    this.decrement_timer = () => {};\n  }\n\n  componentDidUpdate(prevProps) {\n    try {\n      //call when fill value change\n      if (this.props.fill != prevProps.fill) {\n        //if current fill is greater than previous fill then call function for display increasing animated dash\n        if (this.props.fill > prevProps.fill) {\n          this.increaseWeight();\n        } else {\n          //if current fill is less than previous fill then call function for display decreasing animated dash\n          this.decreaseWeight();\n        }\n      }\n    } catch (error) {\n      console.log(\"catch error at in getDerivedStateFromProps  >>>>> \", error);\n    }\n  }\n\n  componentDidMount() {\n    try {\n      this.getPathDirections().then(response => {\n        if (response) {\n          this.increaseWeight();\n        }\n      });\n    } catch (error) {\n      console.log(\"catch error at componentDidMount  >>>>> \", error);\n    }\n  }\n\n  //prepare array to draw dashed\n  getPathDirections() {\n    const {\n      radius,\n      barWidth,\n      strokeThickness,\n      dividerNumber,\n      indicatorWidth,\n      countBars,\n      divideEnabled,\n      trailColor\n    } = this.props;\n\n    return new Promise((resolve, reject) => {\n      try {\n        var count = 0;\n        var dashed = [];\n        var j;\n        var textX;\n        var textY;\n        number = [];\n        var i;\n        var addDividedNumber = false;\n        var text = 0;\n        var ten_counter = 0;\n\n        //calculate center position in svg view\n        const center =\n          radius + Math.max(barWidth, indicatorWidth) + strokeThickness;\n\n        //set 3rd condition of for loop\n        const decrement_i = 360 / ((countBars + 0.001) * 2);\n\n        for (i = 180; i >= 0; i -= decrement_i) {\n          //rotate by 180\n          if (i < 90) {\n            j = i - 90;\n          } else {\n            j = i + 90;\n          }\n\n          const angle = (j * Math.PI) / 90;\n\n          //calculate starting position to end position of dash according to given barwidth\n          var fromX = center + Math.sin(angle) * radius;\n          var fromY = center + Math.cos(angle) * radius;\n\n          var toX = center + Math.sin(angle) * (radius + barWidth);\n          var toY = center + Math.cos(angle) * (radius + barWidth);\n\n          //divide dash group in given dividerNumber\n          if (divideEnabled) {\n            if (ten_counter == (dividerNumber || 10)) {\n              text = text + 1;\n              addDividedNumber = true;\n              var extrawidth = barWidth + responsiveHeight(0.2);\n\n              //calculate position of number\n              textX =\n                center + Math.sin(angle) * (radius - barWidth - extrawidth);\n              textY =\n                center + Math.cos(angle) * (radius - barWidth - extrawidth);\n\n              //calculate starting position to end position of big divider dash\n              fromX = center + Math.sin(angle) * (radius + barWidth);\n              fromY = center + Math.cos(angle) * (radius + barWidth);\n\n              toX = center + Math.sin(angle) * (radius - barWidth);\n              toY = center + Math.cos(angle) * (radius - barWidth);\n\n              ten_counter = 0;\n            }\n\n            if (ten_counter < dividerNumber || 10) {\n              ten_counter = ten_counter + 1;\n            }\n\n            //prepare array for displaying divider number\n            if (addDividedNumber) {\n              number.push({\n                textX: textX,\n                textY: textY,\n                text: text,\n                stroke: trailColor\n              });\n              addDividedNumber = false;\n            }\n          }\n\n          //calculate starting position to end position of stopIndicator according to given indicatorWidth\n          const fromX_stopIndicator =\n            center + Math.sin(angle) * (radius + indicatorWidth);\n          const fromY_stopIndicator =\n            center + Math.cos(angle) * (radius + indicatorWidth);\n\n          const toX_stopIndicator =\n            center + Math.sin(angle) * (radius - barWidth);\n          const toY_stopIndicator =\n            center + Math.cos(angle) * (radius - barWidth);\n\n          var stop_indicator = {\n            fromX: fromX_stopIndicator,\n            fromY: fromY_stopIndicator,\n            toX: toX_stopIndicator,\n            toY: toY_stopIndicator\n          };\n\n          //prepare array for displaying dashed circle\n          dashed.push({\n            fromX: fromX,\n            fromY: fromY,\n            toX: toX,\n            toY: toY,\n            stroke: trailColor,\n            stopIndicator: stop_indicator\n          });\n\n          count = count + 1;\n        }\n\n        this.setState(\n          {\n            reaload: true,\n            bigCircle: dashed,\n            number: number\n          },\n          () => {\n            if (this.state.bigCircle.length <= 0) {\n              resolve(false);\n            }\n          }\n        );\n\n        resolve(true);\n      } catch (error) {\n        console.log(\"catch error at getPathDirections >>>>> \", error);\n      }\n    });\n  }\n\n  //increase animated dash on weight_plate circle\n  increaseWeight() {\n    try {\n      const { strokeColor, fill, duration } = this.props;\n      //divide time interval for each dash\n      var interval_time = 3;\n\n      if (fill > 0) {\n        interval_time = duration / (fill - this.state.last_stroke_index);\n      }\n      var i = this.state.last_trail_index;\n      var k = i;\n      var diff = 1;\n      if (interval_time < 100) {\n        diff = parseInt(100 / interval_time);\n      }\n      //clear all remaining intervals\n      clearInterval(this.increment_timer);\n      clearInterval(this.decrement_timer);\n\n      //intilize new increment interval\n      this.increment_timer = setInterval(() => {\n        try {\n          if (i <= fill) {\n            var bigCircle = this.state.bigCircle;\n            var stopIndicator = this.state.stopIndicator;\n            for (k = i; k <= i + diff; k++) {\n              if (bigCircle.length > k) {\n                if (bigCircle[k].stroke != strokeColor && k <= fill) {\n                  stopIndicator = bigCircle[k].stopIndicator;\n                  bigCircle[k].stroke = strokeColor;\n                } else {\n                  break;\n                }\n              } else {\n                break;\n              }\n            }\n\n            this.setState({\n              last_stroke_index: k - 1,\n              last_trail_index: k,\n              bigCircle: bigCircle,\n              stopIndicator: stopIndicator\n            });\n            i = k;\n          } else {\n            clearInterval(this.increment_timer);\n          }\n        } catch (err) {\n          console.log(err);\n        }\n      }, interval_time);\n    } catch (error) {\n      console.log(\"catch error at increaseWeight >>>>> \", error);\n    }\n  }\n\n  //decrease animated dash on weight_plate circle\n  decreaseWeight() {\n    try {\n      const { trailColor, countBars, fill, duration } = this.props;\n\n      //divide time interval for each dash\n      var interval_time = 3;\n      if (fill >= 0) {\n        interval_time = duration / (this.state.last_trail_index - fill);\n      }\n      var last_length = fill;\n\n      //counter for storing last animated dash\n      var i = this.state.last_stroke_index;\n      if (i >= countBars + 1) {\n        i = countBars;\n      }\n      var k = i;\n      var diff = 1;\n      if (interval_time < 100) {\n        diff = Math.round(100 / interval_time);\n      }\n\n      //clear all remaining intervals\n      clearInterval(this.decrement_timer);\n      clearInterval(this.increment_timer);\n\n      //intilize new decrement interval\n      this.decrement_timer = setInterval(() => {\n        try {\n          if (i >= last_length && i > 0) {\n            var bigCircle = this.state.bigCircle;\n            var stopIndicator = this.state.stopIndicator;\n            for (k = i; k > i - diff; k--) {\n              if (\n                bigCircle[k].stroke != trailColor &&\n                k >= last_length &&\n                k > 0\n              ) {\n                stopIndicator = bigCircle[k].stopIndicator;\n                bigCircle[k].stroke = trailColor;\n              } else {\n                break;\n              }\n            }\n\n            this.setState({\n              last_trail_index: k + 1,\n              last_stroke_index: k,\n              bigCircle: bigCircle,\n              stopIndicator: stopIndicator\n            });\n\n            i = k;\n          } else {\n            clearInterval(this.decrement_timer);\n          }\n        } catch (err) {\n          console.log(err);\n        }\n      }, interval_time);\n    } catch (error) {\n      console.log(\"catch error at decreaseWeight >>>>> \", error);\n    }\n  }\n\n  render() {\n    const {\n      containerStyle,\n      fill,\n      radius,\n      barWidth,\n      strokeThickness,\n      strokeLinecap,\n      showTooltip,\n      tooltipSize,\n      tooltipColor,\n      tooltipFamily,\n      divideEnabled,\n      text,\n      dividerNumberSize,\n      showIndicator,\n      strokeColor,\n      indicatorWidth,\n      indicatorColor\n    } = this.props;\n\n    //calculate size of svg view\n    const center =\n      radius + Math.max(barWidth, indicatorWidth) + strokeThickness;\n    const size = center * 2;\n\n    //adjust fontSize of middle text\n    var textFontSize = tooltipSize || 12;\n    if (tooltipSize != undefined) {\n      if (tooltipSize >= center) {\n        textFontSize = center;\n      } else {\n        textFontSize = tooltipSize;\n      }\n    }\n\n    return (\n      <View style={containerStyle}>\n        <Svg\n          width={`${size}`}\n          height={`${size}`}\n          style={{ backgroundColor: \"transparent\" }}\n        >\n          {/*display animated circle view*/}\n          {this.state.bigCircle.map((item, index) => (\n            <Line\n              key={`line_${index}`}\n              x1={item.fromX}\n              y1={item.fromY}\n              x2={item.toX}\n              y2={item.toY}\n              stroke={item.stroke}\n              strokeWidth={strokeThickness}\n              strokeLinecap={strokeLinecap}\n            />\n          ))}\n\n          {/*drawing divided lines and number */}\n          {divideEnabled &&\n            this.state.number.map((item, index) => (\n              <Text\n                key={`number_${index}`}\n                x={item.textX}\n                y={item.textY + (dividerNumberSize || 9) / 3}\n                fill={item.stroke}\n                fontSize={dividerNumberSize || 9}\n                textAnchor=\"middle\"\n              >\n                {item.text}\n              </Text>\n            ))}\n\n          {/* display stop indicator at fill */}\n          {showIndicator && (\n            <Line\n              x1={this.state.stopIndicator.fromX}\n              y1={this.state.stopIndicator.fromY}\n              x2={this.state.stopIndicator.toX}\n              y2={this.state.stopIndicator.toY}\n              stroke={indicatorColor}\n              strokeWidth={strokeThickness}\n              strokeLinecap={strokeLinecap}\n            />\n          )}\n\n          {/*middle text*/}\n          {showTooltip && (\n            <Text\n              x={center}\n              y={center + textFontSize / 3}\n              textAnchor=\"middle\"\n              fontSize={textFontSize}\n              fontFamily={tooltipFamily}\n              fill={tooltipColor}\n            >\n              {text || fill + \"%\"}\n            </Text>\n          )}\n        </Svg>\n      </View>\n    );\n  }\n}\n\nfunction isPositiveNumber(response) {\n  if (response.fill < 0) {\n    console.error(new Error(\"fill must be greater than or equal to 0\"));\n  } else if (response.fill > response.countBars) {\n    console.error(\n      new Error(`fill must be less than or equal to ${response.countBars}`)\n    );\n  }\n}\n\nDashedProgress.propTypes = {\n  radius: PropTypes.number,\n  barWidth: PropTypes.number,\n  indicatorWidth: PropTypes.number,\n  countBars: PropTypes.number,\n  strokeThickness: PropTypes.number,\n  fill: isPositiveNumber,\n  strokeLinecap: PropTypes.string,\n  trailColor: PropTypes.string,\n  strokeColor: PropTypes.string,\n  tooltipColor: PropTypes.string,\n  text: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  tooltipSize: PropTypes.number,\n  showTooltip: PropTypes.bool,\n  dividerNumber: PropTypes.number,\n  dividerNumberSize: PropTypes.number,\n  showIndicator: PropTypes.bool,\n  indicatorColor: PropTypes.string,\n  divideEnabled: PropTypes.bool,\n  duration: PropTypes.number,\n  containerStyle: PropTypes.object,\n  tooltipFamily: PropTypes.string\n};\n\nDashedProgress.defaultProps = {\n  radius: 100,\n  countBars: 100,\n  barWidth: 10,\n  indicatorWidth: 20,\n  strokeThickness: 1,\n  fill: 50,\n  trailColor: \"#000000\",\n  strokeColor: \"#008000\",\n  indicatorColor: \"#008000\",\n  tooltipColor: \"#008000\",\n  duration: 1000,\n  strokeLinecap: \"round\",\n  showIndicator: true,\n  showTooltip: true,\n  divideEnabled: false\n};\n"]},"metadata":{},"sourceType":"module"}